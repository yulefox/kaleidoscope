# gRPC 核心概念

## 概述

### 服务定义

gRPC 默认使用 protobuf 作为接口定义语言, 支持以下服务方法:

- 一元 RPC. 客户端发送一个请求到服务端, 服务端返回一个相应. 如同一次函数调用.

```protobuf
rpc SayHello (HelloRequest) returns (HelloResponse) {}
```

- 服务端流 RPC. 客户端发送一个请求到服务端, 从服务端返回的数据流中读取一连串的消息.

```protobuf
rpc LotsOfReplies (HelloRequest) returns (stream HelloResponse) {}
```

- 客户端流 RPC. 客户端将一连串消息写入数据流并发送到服务端, 服务端返回一个应答.

```protobuf
rpc LotsOfGreetings (stream HelloRequest) returns (HelloResponse) {}
```

- 双向流 RPC. 客户端及服务端均通过读写流发送一连串消息. 两个流的操作相互独立.

```protobuf
rpc BidiHello(stream HelloRequest) returns (stream HelloResponse) {}
```

### API 使用

gRPC 提供了 protobuf 编译插件以生成客户端/服务端代码. 用户在客户端调用 API, 在服务器实现 API.

- 在服务端, 实现了服务中声明的方法, 运行 gRPC 服务, 解码并处理客户端调用请求, 编码相应结果, 发送给客户端.

- 在客户端, 有一个本地的桩对象, 实现了服务中声明的同一方法, 通过本地桩对象调用该方法, 将调用参数封装在 protobuf 消息中, 发送请求到服务端, 接收服务端应答结果.

### 同步与异步

同步 RPC 的调用会阻塞, 直到接收到服务端的应答结果, 这与 RPC 调用的期望比较接近, 就像本地调用一样. 另一方面, 在很多场景中, 网络内部异步执行, 不阻塞当前线程的调用更有意义.

当然, 大多数编程语言的 gRPC 实现都同时支持同步和异步两种使用.

## RPC 生命周期

现在, 来深入了解一下当客户端调用服务端的 gRPC 方法时到底发生了什么.

### 一元 RPC

- 一旦客户端调用服务方法, 就会通知服务端 RPC 已被调用, 通知数据包括客户端的元数据, 方法名称, 生命周期等.

- 服务端有两个选择: 立即直接发回初始元数据, 或者等待客户端的请求消息.

- 服务器收到客户端请求消息后, 即可创建和填充应答消息, 然后将应答消息(如果成功), 状态详细信息(状态码, 可选的状态消息), 及尾随元数据(可选)发送给客户端.

- 如果状态是 OK, 客户端收到应答, 完成客户端的 RPC 调用.

### 服务端流 RPC

服务端流 RPC 在收到客户端请求消息后, 发回的应答是流数据. 流数据发送完毕, 服务端的状态详细信息(状态码, 可选的状态消息)及尾随元数据(可选)发送给客户端, 完成服务端应答. 收到所有应答后, 客户端完成调用.

### 客户端流 RPC

类似地, 客户端流 RPC 发送的请求是流数据. 通常(非必需)服务端在收到所有客户端请求消息, 状态详细信息(状态码, 可选的状态消息)及尾随元数据(可选)后, 返回单个应答消息给客户端.

### 双向流 RPC

在双向流 RPC 中, 客户端调用 RPC 方法, 服务端收到客户端元数据, 方法名及生命周期. 服务端可选择发回初始元数据或是等待客户端发送请求.

接下来取决于应用自身实现. 客户端及服务端可以按任意顺序读写, 流操作是完全独立的. 例如, 服务端可以等接收完所有客户端请求后再发送应答, 也可以一收一发.

### 生命周期

gRPC 允许客户端指定 RPC 结束的等待时长(`DEADLINE_EXCEEDED`). 在服务端, 可查询 PRC 是否超时, 或剩余生命周期.

具体实现因语言而已.

### RPC 结束

在 gRPC 中, 客户端与服务端均独立判断调用是否成功, 双方的结论可能并不一致. 这就意味着, 可能出现服务端正常结束(*发出所有应答消息*), 客户端却以失败结束(*应答在生命周期结束后才到达*), 也可能出现在客户端发出所有请求前服务端即已结束的情况.

### 取消 RPC

客户端与服务端均可在任意时刻取消 RPC. 取消操作将立即结束 RPC 调用. 取消不是撤销, 取消操作前的变更不会被回滚.

### 元数据

元数据记录了 RPC 的调用信息(验证细节等), 以键值对列表的形式呈现, 键为字符串, 值通常也是字符串(也可以是二进制数据). 元数据对 gRPC 自身是不透明的, 使客户端在调用服务端方法时可以提供必要信息, 反之亦然.

访问元数据的方法是语言依赖的.

### 通道

gRPC 通道建立一个到给定主机端口的服务器的连接, 客户端可指定通道参数以调整 gRPC 缺省行为, 如启用/关闭消息压缩. 通道有 `connected` 及 `idle` 两个状态.

gRPC 处理通道关闭的实现是语言依赖的, 部分语言支持查询通道状态.